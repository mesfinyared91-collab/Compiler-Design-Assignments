ğŸ“˜ Intermediate Code Generation â€“ Compiler Design
ğŸ“Œ Overview

This repository contains Assignment-02 for the Compiler Design course.
It focuses on Intermediate Code Generation (ICG), a crucial phase of a compiler that bridges the front end and back end by converting high-level source code into a machine-independent Intermediate Representation (IR).

ğŸ¯ Objectives

Understand the role of Intermediate Code Generation in compiler design

Explain why machine-independent IR is essential for portability and optimization

Study different types of Intermediate Representations

Analyze real-world usage of IR (Java Bytecode case study)

ğŸ” Topics Covered

ğŸ“Œ Definition and purpose of Intermediate Code Generation

âš™ï¸ Role of ICG in compiler phases

ğŸ§© Types of Intermediate Code:

Graphical IRs

Abstract Syntax Tree (AST)

Directed Acyclic Graph (DAG)

Control Flow Graph (CFG)

Linear IRs

Postfix Notation

Three Address Code (TAC)

ğŸš€ Applications and importance of IR

â˜• Case study: Java Compiler and Bytecode

âœ… Advantages and âŒ disadvantages of Intermediate Code Generation

ğŸ›  Key Concepts Explained

Portability: Same IR works across different machines

Optimization: Code can be optimized before final code generation

Retargetability: Easier to generate code for multiple architectures

Simplified Compiler Design: One optimizer, multiple code generators

ğŸ“‚ Repository Contents

ğŸ“‘ Assignment-2.pptx â€“ Presentation on Intermediate Code Generation

ğŸ“„ README.md â€“ Project description and overview

ğŸ“š References

Compilers: Principles, Techniques, and Tools â€“ Aho et al.

Compiler Design lecture notes

Online compiler resources
